/**
 * Shipment & Movement Phase Handler
 *
 * Phase 1.06: Shipment & Movement
 *
 * CRITICAL ARCHITECTURE (Rule 1.06.12.01):
 * - Each faction does BOTH ship AND move before next faction acts
 * - NOT separate sub-phases! Process sequentially by faction
 * - Spacing Guild can act out of storm order (SHIP AS IT PLEASES YOU)
 * - Alliance constraint applied AFTER EACH faction completes
 *
 * Rule references:
 * - 1.06.12.01: "First Player conducts Force Shipment action and then Force Movement action"
 * - 2.06.12.01: "SHIP AND MOVE AHEAD OF SCHEDULE" (Guild acts before turn)
 * - 2.06.12.02: "HOLDING PATTERN" (Guild delays to go last)
 * - 1.06.03.08: "CONSTRAINT: At the end of your Shipment and Movement actions..."
 */

import {
  Faction,
  Phase,
  TerritoryId,
  TerritoryType,
  type GameState,
  TERRITORY_DEFINITIONS,
  FACTION_NAMES,
} from '../../types';
import {
  shipForces,
  moveForces,
  removeSpice,
  addSpice,
  getFactionState,
  logAction,
  getForceCountInTerritory,
  getFactionsInTerritory,
  sendForcesToTanks,
} from '../../state';
import { GAME_CONSTANTS } from '../../data';
import { checkOrnithopterAccess, getMovementRange, validateShipment, validateMovement } from '../../rules';
import {
  type PhaseHandler,
  type PhaseStepResult,
  type AgentRequest,
  type AgentResponse,
  type PhaseEvent,
} from '../types';

// =============================================================================
// SHIPMENT & MOVEMENT PHASE HANDLER
// =============================================================================

/**
 * Guild timing state machine:
 * - 'not_decided': Guild hasn't decided when to act
 * - 'acting_now': Guild is currently acting (ship + move)
 * - 'waiting': Guild declined to act now
 * - 'completed': Guild has completed both actions
 */
type GuildTimingState = 'not_decided' | 'acting_now' | 'waiting' | 'completed';

/**
 * Current faction's phase within their turn
 */
type FactionPhase = 'AWAITING_SHIP' | 'AWAITING_MOVE' | 'COMPLETED';

export class ShipmentMovementPhaseHandler implements PhaseHandler {
  readonly phase = Phase.SHIPMENT_MOVEMENT;

  // Sequential processing: each faction does ship+move before next
  private currentFactionIndex = 0;
  private factionsCompleted: Set<Faction> = new Set();

  // Guild special timing (Rule 2.06.12)
  private guildTimingState: GuildTimingState = 'not_decided';
  private guildDelayed: boolean = false; // Guild chose HOLDING PATTERN

  // Track what the current faction is doing
  private currentFactionPhase: FactionPhase = 'AWAITING_SHIP';
  private currentFaction: Faction | null = null;

  initialize(state: GameState): PhaseStepResult {
    // Reset all state
    this.currentFactionIndex = 0;
    this.factionsCompleted = new Set();
    this.guildTimingState = 'not_decided';
    this.guildDelayed = false;
    this.currentFactionPhase = 'AWAITING_SHIP';
    this.currentFaction = null;

    const events: PhaseEvent[] = [];

    console.log('\n' + '='.repeat(80));
    console.log('üö¢ SHIPMENT & MOVEMENT PHASE (Turn ' + state.turn + ')');
    console.log('='.repeat(80));
    console.log(`\nüìç Storm Sector: ${state.stormSector}`);
    console.log(`üìã Storm Order: ${state.stormOrder.map(f => FACTION_NAMES[f]).join(' ‚Üí ')}`);
    console.log(`\n  Rule 1.06.12.01: Each faction does SHIPMENT then MOVEMENT sequentially.`);
    console.log(`  Play proceeds in Storm Order until all players complete.\n`);

    if (state.factions.has(Faction.SPACING_GUILD)) {
      console.log(`  ‚ö†Ô∏è  Spacing Guild: Can act out of order (SHIP AS IT PLEASES YOU)`);
      console.log(`     - AHEAD OF SCHEDULE (2.06.12.01): Act before normal turn`);
      console.log(`     - HOLDING PATTERN (2.06.12.02): Delay to go last\n`);
    }
    console.log('='.repeat(80) + '\n');

    // Rule 2.06.12: Ask Guild if they want to act first
    if (state.factions.has(Faction.SPACING_GUILD)) {
      return this.askGuildTiming(state, events, 'before_first');
    }

    // Start with first faction in storm order
    return this.startNextFaction(state, events);
  }

  processStep(state: GameState, responses: AgentResponse[]): PhaseStepResult {
    const events: PhaseEvent[] = [];
    let newState = state;

    // 1. Handle Guild timing decision
    if (this.isWaitingForGuildTimingDecision(responses)) {
      return this.processGuildTimingDecision(newState, responses, events);
    }

    // 1b. Handle BG spiritual advisor decision (triggered after another faction ships)
    if (this.waitingForBGSpiritualAdvisor) {
      return this.processBGSpiritualAdvisorDecision(newState, responses, events);
    }

    // 2. Handle current faction's action
    const currentResponse = responses.find(r => r.factionId === this.currentFaction);
    if (!currentResponse) {
      console.error(`‚ö†Ô∏è  No response from ${this.currentFaction}`);
      return this.advanceToNextAction(newState, events);
    }

    // 3. Process based on what we're waiting for
    if (this.currentFactionPhase === 'AWAITING_SHIP') {
      // Process shipment
      let shippedSuccessfully = false;
      let shipmentTerritory: TerritoryId | undefined;
      let shipmentSector: number | undefined;

      if (!currentResponse.passed && currentResponse.actionType === 'SHIP_FORCES') {
        const result = this.processShipment(newState, currentResponse, events);
        newState = result.state;
        events.push(...result.events);

        // Track shipment for BG spiritual advisor
        shippedSuccessfully = true;
        shipmentTerritory = currentResponse.data.territoryId as TerritoryId | undefined;
        shipmentSector = currentResponse.data.sector as number | undefined;
      } else {
        console.log(`   ‚è≠Ô∏è  ${FACTION_NAMES[this.currentFaction!]} passes on shipment\n`);
      }

      // Rule 2.02.05: BG Spiritual Advisors - After ANY other faction ships from off-planet
      // Check if BG spiritual advisor should be triggered
      if (shippedSuccessfully &&
          this.currentFaction !== Faction.BENE_GESSERIT &&
          newState.factions.has(Faction.BENE_GESSERIT) &&
          shipmentTerritory &&
          shipmentSector !== undefined) {
        // Check if BG has reserves
        const bgState = getFactionState(newState, Faction.BENE_GESSERIT);
        const bgReserves = bgState.forces.reserves.regular + bgState.forces.reserves.elite;

        if (bgReserves > 0) {
          // Trigger BG spiritual advisor
          console.log(`\n‚ö° SPIRITUAL ADVISORS: ${FACTION_NAMES[this.currentFaction!]} shipped to ${shipmentTerritory}`);
          console.log(`   Bene Gesserit may send 1 force for free (Rule 2.02.05)\n`);

          return this.requestBGSpiritualAdvisor(newState, events, shipmentTerritory, shipmentSector);
        }
      }

      // Move to movement phase for this faction
      this.currentFactionPhase = 'AWAITING_MOVE';
      return this.requestMovementDecision(newState, events);
    }
    else if (this.currentFactionPhase === 'AWAITING_MOVE') {
      // Process movement
      if (!currentResponse.passed && currentResponse.actionType === 'MOVE_FORCES') {
        const result = this.processMovement(newState, currentResponse, events);
        newState = result.state;
        events.push(...result.events);
      } else {
        console.log(`   ‚è≠Ô∏è  ${FACTION_NAMES[this.currentFaction!]} passes on movement\n`);
      }

      // This faction is done - mark as completed
      this.factionsCompleted.add(this.currentFaction!);
      this.currentFactionPhase = 'COMPLETED';

      // Rule 1.06.03.08: Apply alliance constraint immediately after this faction
      console.log(`\n   ‚úÖ ${FACTION_NAMES[this.currentFaction!]} completed ship + move`);
      const allianceResult = this.applyAllianceConstraintForFaction(
        newState,
        this.currentFaction!,
        events
      );
      newState = allianceResult.state;
      events.push(...allianceResult.events);

      // Move to next faction
      return this.advanceToNextAction(newState, events);
    }

    // Shouldn't reach here
    return this.advanceToNextAction(newState, events);
  }

  cleanup(state: GameState): GameState {
    // All alliance constraints applied during processStep
    return state;
  }

  // ===========================================================================
  // GUILD TIMING (Rule 2.06.12)
  // ===========================================================================

  /**
   * Ask Guild if they want to act now (before the next faction)
   * Context: 'before_first' | 'before_faction' | 'guild_turn'
   */
  private askGuildTiming(
    state: GameState,
    events: PhaseEvent[],
    context: 'before_first' | 'before_faction' | 'guild_turn'
  ): PhaseStepResult {
    if (this.guildTimingState !== 'not_decided') {
      // Guild already acted or is waiting
      return this.startNextFaction(state, events);
    }

    const nextFaction = this.getNextFactionInStormOrder(state);
    const nextFactionName = nextFaction ? FACTION_NAMES[nextFaction] : 'end of phase';

    let prompt = '';
    if (context === 'before_first') {
      prompt = `AHEAD OF SCHEDULE: Do you want to act FIRST, before ${nextFactionName}? (You can ship and move before everyone else)`;
      console.log(`\n‚è∞ GUILD TIMING: Do you want to go FIRST?`);
    } else if (context === 'guild_turn') {
      prompt = `HOLDING PATTERN: It's your normal turn. Do you want to ACT NOW, or DELAY to go last? (After all other factions)`;
      console.log(`\n‚è∞ GUILD TIMING: It's your turn. Act now or delay to go last?`);
    } else {
      prompt = `AHEAD OF SCHEDULE: Do you want to act NOW, before ${nextFactionName}? (Or continue waiting)`;
      console.log(`\n‚è∞ GUILD TIMING: Do you want to act before ${nextFactionName}?`);
    }

    console.log(`   Next faction: ${nextFactionName}\n`);

    const pendingRequests: AgentRequest[] = [
      {
        factionId: Faction.SPACING_GUILD,
        requestType: 'GUILD_TIMING_DECISION',
        prompt,
        context: {
          nextFaction: nextFactionName,
          context,
          isGuildTurn: context === 'guild_turn',
          canDelay: context === 'guild_turn',
        },
        availableActions: ['guild_act_now', 'guild_wait', 'guild_delay'],
      },
    ];

    return {
      state,
      phaseComplete: false,
      pendingRequests,
      actions: [],
      events,
    };
  }

  private isWaitingForGuildTimingDecision(responses: AgentResponse[]): boolean {
    return this.guildTimingState === 'not_decided' &&
           responses.some(r =>
             r.factionId === Faction.SPACING_GUILD &&
             r.actionType === 'GUILD_TIMING_DECISION'
           );
  }

  private processGuildTimingDecision(
    state: GameState,
    responses: AgentResponse[],
    events: PhaseEvent[]
  ): PhaseStepResult {
    const guildResponse = responses.find(r => r.factionId === Faction.SPACING_GUILD);
    if (!guildResponse) {
      // No response, treat as wait
      this.guildTimingState = 'waiting';
      return this.startNextFaction(state, events);
    }

    const decision = guildResponse.data?.decision as string | undefined;

    if (decision === 'act_now' || guildResponse.actionType === 'GUILD_ACT_NOW') {
      // Guild wants to act now
      console.log(`\n   ‚úÖ Guild chooses: ACT NOW (AHEAD OF SCHEDULE)\n`);
      this.guildTimingState = 'acting_now';
      this.currentFaction = Faction.SPACING_GUILD;
      this.currentFactionPhase = 'AWAITING_SHIP';
      return this.requestShipmentDecision(state, events);
    }
    else if (decision === 'delay' || guildResponse.actionType === 'GUILD_DELAY') {
      // Guild delays (HOLDING PATTERN)
      console.log(`\n   ‚è∏Ô∏è  Guild chooses: DELAY (HOLDING PATTERN - will go last)\n`);
      this.guildTimingState = 'waiting';
      this.guildDelayed = true;
      this.factionsCompleted.add(Faction.SPACING_GUILD); // Skip in normal order
      return this.startNextFaction(state, events);
    }
    else {
      // Guild waits
      console.log(`\n   ‚è∏Ô∏è  Guild chooses: WAIT (will be asked again)\n`);
      this.guildTimingState = 'waiting';
      return this.startNextFaction(state, events);
    }
  }

  // ===========================================================================
  // FACTION SEQUENCING
  // ===========================================================================

  /**
   * Get next faction in storm order that hasn't completed
   */
  private getNextFactionInStormOrder(state: GameState): Faction | null {
    for (let i = this.currentFactionIndex; i < state.stormOrder.length; i++) {
      const faction = state.stormOrder[i];
      if (!this.factionsCompleted.has(faction)) {
        return faction;
      }
    }
    return null;
  }

  /**
   * Start the next faction's turn (ship + move)
   */
  private startNextFaction(state: GameState, events: PhaseEvent[]): PhaseStepResult {
    // Find next faction in storm order
    while (this.currentFactionIndex < state.stormOrder.length) {
      const faction = state.stormOrder[this.currentFactionIndex];

      if (this.factionsCompleted.has(faction)) {
        this.currentFactionIndex++;
        continue;
      }

      // Check if this is Guild's normal turn
      if (faction === Faction.SPACING_GUILD && this.guildTimingState === 'not_decided') {
        return this.askGuildTiming(state, events, 'guild_turn');
      }

      // Check if Guild wants to act before this faction
      if (state.factions.has(Faction.SPACING_GUILD) &&
          this.guildTimingState === 'waiting' &&
          !this.factionsCompleted.has(Faction.SPACING_GUILD)) {
        // Reset Guild state to ask again
        this.guildTimingState = 'not_decided';
        return this.askGuildTiming(state, events, 'before_faction');
      }

      // Start this faction's turn
      this.currentFaction = faction;
      this.currentFactionPhase = 'AWAITING_SHIP';
      return this.requestShipmentDecision(state, events);
    }

    // All normal factions done - check if Guild delayed
    if (this.guildDelayed && !this.factionsCompleted.has(Faction.SPACING_GUILD)) {
      // Remove Guild from completed (it was added to skip normal turn)
      this.factionsCompleted.delete(Faction.SPACING_GUILD);
      console.log(`\nüï∞Ô∏è  HOLDING PATTERN: Guild goes last\n`);
      this.currentFaction = Faction.SPACING_GUILD;
      this.currentFactionPhase = 'AWAITING_SHIP';
      this.guildTimingState = 'acting_now';
      this.guildDelayed = false;
      return this.requestShipmentDecision(state, events);
    }

    // Phase complete!
    console.log(`\n‚úÖ All factions have completed Shipment & Movement\n`);
    console.log('='.repeat(80) + '\n');

    return {
      state,
      phaseComplete: true,
      nextPhase: Phase.BATTLE,
      pendingRequests: [],
      actions: [],
      events,
    };
  }

  /**
   * Move to next action (either faction's movement, or next faction)
   */
  private advanceToNextAction(state: GameState, events: PhaseEvent[]): PhaseStepResult {
    // Current faction completed both actions - move to next faction
    this.currentFactionIndex++;
    return this.startNextFaction(state, events);
  }

  // ===========================================================================
  // REQUEST METHODS
  // ===========================================================================

  private requestShipmentDecision(
    state: GameState,
    events: PhaseEvent[]
  ): PhaseStepResult {
    if (!this.currentFaction) {
      return this.startNextFaction(state, events);
    }

    const faction = this.currentFaction;
    const factionState = getFactionState(state, faction);
    const reserves = factionState.forces.reserves;
    const totalReserves = reserves.regular + reserves.elite;

    const isGuild = faction === Faction.SPACING_GUILD;
    const hasGuild = state.factions.has(Faction.SPACING_GUILD);
    const baseShippingCost = GAME_CONSTANTS.SHIPMENT_COST;

    // Calculate costs
    let costToStronghold: number = baseShippingCost;
    let costElsewhere: number = baseShippingCost * 2;
    if (isGuild) {
      // Guild pays half price (Rule 2.06.07: HALF PRICE SHIPPING)
      costToStronghold = Math.ceil(costToStronghold / 2);
      costElsewhere = Math.ceil(costElsewhere / 2);
    }

    console.log(`\nüö¢ SHIPMENT: ${FACTION_NAMES[faction]}`);
    console.log(`   Reserves: ${totalReserves} forces (${reserves.regular} regular, ${reserves.elite} elite)`);
    console.log(`   Spice: ${factionState.spice}`);
    console.log(`   Cost: ${costToStronghold}/force (strongholds), ${costElsewhere}/force (elsewhere)`);

    const validDestinations = this.getValidShippingDestinations(state, faction);

    const pendingRequests: AgentRequest[] = [
      {
        factionId: faction,
        requestType: 'SHIP_FORCES',
        prompt: `Shipment: You have ${totalReserves} forces in reserves. Cost: ${costToStronghold} spice per force to strongholds, ${costElsewhere} elsewhere. Do you want to ship forces?`,
        context: {
          reservesRegular: reserves.regular,
          reservesElite: reserves.elite,
          totalReserves,
          spiceAvailable: factionState.spice,
          shippingCostToStronghold: costToStronghold,
          shippingCostElsewhere: costElsewhere,
          isGuild,
          guildInGame: hasGuild,
          validDestinations,
          phase: 'shipment',
          willMoveAfter: true,
        },
        availableActions: ['SHIP_FORCES', 'PASS'],
      },
    ];

    return {
      state,
      phaseComplete: false,
      pendingRequests,
      actions: [],
      events,
    };
  }

  private requestMovementDecision(
    state: GameState,
    events: PhaseEvent[]
  ): PhaseStepResult {
    if (!this.currentFaction) {
      return this.startNextFaction(state, events);
    }

    const faction = this.currentFaction;
    const factionState = getFactionState(state, faction);
    const hasOrnithopters = checkOrnithopterAccess(state, faction);
    const movementRange = getMovementRange(state, faction);

    console.log(`\nüö∂ MOVEMENT: ${FACTION_NAMES[faction]}`);
    console.log(`   Movement Range: ${movementRange} territory${movementRange !== 1 ? 'ies' : ''}${hasOrnithopters ? ' (Ornithopters)' : ''}`);

    const movableForces = factionState.forces.onBoard.map((stack) => ({
      territoryId: stack.territoryId,
      sector: stack.sector,
      regular: stack.forces.regular,
      elite: stack.forces.elite,
      total: stack.forces.regular + stack.forces.elite,
    }));

    const pendingRequests: AgentRequest[] = [
      {
        factionId: faction,
        requestType: 'MOVE_FORCES',
        prompt: `Movement: You have ${movableForces.length} force stacks. Movement range: ${movementRange} territories${hasOrnithopters ? ' (ornithopters)' : ''}.`,
        context: {
          movableForces,
          movementRange,
          hasOrnithopters,
          stormSector: state.stormSector,
          phase: 'movement',
        },
        availableActions: ['MOVE_FORCES', 'PASS'],
      },
    ];

    return {
      state,
      phaseComplete: false,
      pendingRequests,
      actions: [],
      events,
    };
  }

  // ===========================================================================
  // PROCESSING METHODS
  // ===========================================================================

  private processShipment(
    state: GameState,
    response: AgentResponse,
    events: PhaseEvent[]
  ): { state: GameState; events: PhaseEvent[] } {
    const newEvents: PhaseEvent[] = [];
    const faction = response.factionId;

    // Tool returns: { territoryId, sector, count, cost, ... }
    const territoryId = response.data.territoryId as TerritoryId | undefined;
    const sector = response.data.sector as number | undefined;
    const count = response.data.count as number | undefined;
    const cost = response.data.cost as number | undefined;

    if (!territoryId || count === undefined) {
      return { state, events: newEvents };
    }

    console.log(`   ‚úÖ Shipped ${count} forces to ${territoryId} (sector ${sector ?? 0}) for ${cost ?? 0} spice\n`);

    newEvents.push({
      type: 'FORCES_SHIPPED',
      data: { faction, territory: territoryId, sector, count, cost },
      message: `${FACTION_NAMES[faction]} ships ${count} forces to ${territoryId} (sector ${sector ?? 0}) for ${cost ?? 0} spice`,
    });

    const newState = logAction(state, 'FORCES_SHIPPED', faction, {
      territory: territoryId,
      sector,
      count,
      cost,
    });

    return { state: newState, events: newEvents };
  }

  private processMovement(
    state: GameState,
    response: AgentResponse,
    events: PhaseEvent[]
  ): { state: GameState; events: PhaseEvent[] } {
    const newEvents: PhaseEvent[] = [];
    const faction = response.factionId;

    // Tool returns: { from: { territory, sector }, to: { territory, sector }, count }
    const fromData = response.data.from as { territory?: string; sector?: number } | undefined;
    const toData = response.data.to as { territory?: string; sector?: number } | undefined;
    const count = response.data.count as number | undefined;

    if (!fromData?.territory || !toData?.territory || count === undefined) {
      return { state, events: newEvents };
    }

    console.log(`   ‚úÖ Moved ${count} forces from ${fromData.territory} to ${toData.territory}\n`);

    newEvents.push({
      type: 'FORCES_MOVED',
      data: {
        faction,
        from: fromData.territory,
        fromSector: fromData.sector,
        to: toData.territory,
        toSector: toData.sector,
        count,
      },
      message: `${FACTION_NAMES[faction]} moves ${count} forces from ${fromData.territory} to ${toData.territory}`,
    });

    const newState = logAction(state, 'FORCES_MOVED', faction, {
      from: fromData.territory,
      fromSector: fromData.sector,
      to: toData.territory,
      toSector: toData.sector,
      count,
    });

    return { state: newState, events: newEvents };
  }

  // ===========================================================================
  // ALLIANCE CONSTRAINT (Rule 1.06.03.08)
  // ===========================================================================

  /**
   * Apply alliance constraint for a specific faction that just completed actions.
   *
   * Rule 1.06.03.08: "At the end of your Shipment and Movement actions,
   * Place all your Forces that are in the same Territory (except the Polar Sink)
   * as your Ally's Forces in the Tleilaxu Tanks."
   *
   * CRITICAL: Applied AFTER EACH faction completes, not at end of phase!
   */
  private applyAllianceConstraintForFaction(
    state: GameState,
    faction: Faction,
    events: PhaseEvent[]
  ): { state: GameState; events: PhaseEvent[] } {
    const newEvents: PhaseEvent[] = [];
    let newState = state;

    const factionState = state.factions.get(faction);
    if (!factionState) return { state, events: newEvents };

    const allyId = factionState.allyId;
    if (!allyId) {
      // No ally, no constraint
      return { state, events: newEvents };
    }

    const allyState = state.factions.get(allyId);
    if (!allyState) return { state, events: newEvents };

    // Get all territories where this faction has forces
    const factionTerritories = new Set<TerritoryId>();
    for (const stack of factionState.forces.onBoard) {
      factionTerritories.add(stack.territoryId);
    }

    // Check each territory for ally presence
    for (const territoryId of Array.from(factionTerritories)) {
      // Rule: Except Polar Sink
      if (territoryId === TerritoryId.POLAR_SINK) continue;

      const occupants = getFactionsInTerritory(newState, territoryId);
      if (occupants.includes(allyId)) {
        // Ally is in this territory - send all forces to tanks
        const forcesInTerritory = factionState.forces.onBoard.filter(
          (s) => s.territoryId === territoryId
        );

        let totalForces = 0;
        for (const stack of forcesInTerritory) {
          totalForces += stack.forces.regular + stack.forces.elite;
        }

        if (totalForces > 0) {
          console.log(
            `\n   ‚ö†Ô∏è  ALLIANCE CONSTRAINT: ${FACTION_NAMES[faction]} has ${totalForces} forces in ${territoryId} with ally ${FACTION_NAMES[allyId]}`
          );
          console.log(`   üóëÔ∏è  Sending ${totalForces} forces to Tleilaxu Tanks (Rule 1.06.03.08)\n`);

          // Send all forces in this territory to tanks
          for (const stack of forcesInTerritory) {
            const count = stack.forces.regular + stack.forces.elite;
            newState = sendForcesToTanks(
              newState,
              faction,
              territoryId,
              stack.sector,
              count
            );
          }

          newEvents.push({
            type: 'FORCES_SHIPPED',
            data: {
              faction,
              territory: territoryId,
              count: totalForces,
              reason: 'alliance_constraint',
            },
            message: `${FACTION_NAMES[faction]} sends ${totalForces} forces to tanks (alliance constraint: same territory as ${FACTION_NAMES[allyId]})`,
          });

          newState = logAction(newState, 'FORCES_SHIPPED', faction, {
            territory: territoryId,
            count: totalForces,
            reason: 'alliance_constraint',
          });
        }
      }
    }

    return { state: newState, events: newEvents };
  }

  // ===========================================================================
  // HELPER METHODS
  // ===========================================================================

  private getValidShippingDestinations(
    state: GameState,
    faction: Faction
  ): { territoryId: TerritoryId; sector: number; isStronghold: boolean; costMultiplier: number }[] {
    const destinations: { territoryId: TerritoryId; sector: number; isStronghold: boolean; costMultiplier: number }[] = [];

    for (const [id, territory] of Object.entries(TERRITORY_DEFINITIONS)) {
      const territoryId = id as TerritoryId;

      // Can't ship to polar sink
      if (territory.type === TerritoryType.POLAR_SINK) continue;

      // Check each sector (can't ship into storm)
      for (const sector of territory.sectors) {
        if (sector === state.stormSector) continue;

        destinations.push({
          territoryId,
          sector,
          isStronghold: territory.type === TerritoryType.STRONGHOLD,
          costMultiplier: territory.type === TerritoryType.STRONGHOLD ? 1 : 2,
        });
      }
    }

    return destinations;
  }
}
