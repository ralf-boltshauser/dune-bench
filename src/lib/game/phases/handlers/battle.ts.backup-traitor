/**
 * Battle Phase Handler
 *
 * Phase 1.07: Battle
 * - Identify territories with multiple factions
 * - Battles occur in storm order
 * - Sub-phases: Choose battle, battle plans, prescience, voice, reveal, traitor, resolution
 */

import {
  Faction,
  Phase,
  BattleSubPhase,
  TerritoryId,
  LeaderLocation,
  type GameState,
  type BattlePlan,
} from '../../types';
import {
  sendForcesToTanks,
  killLeader,
  markLeaderUsed,
  resetLeaderTurnState,
  returnLeaderToPool,
  getFactionState,
  logAction,
  getFactionsInTerritory,
  getAlly,
  addSpice,
  updateKwisatzHaderach,
  markKwisatzHaderachUsed,
  resetKwisatzHaderachTurnState,
  removeTraitorCard,
} from '../../state';
import { resolveBattle, resolveTwoTraitorsBattle, validateBattlePlan, validateVoiceCompliance, type BattleResult } from '../../rules';
import { getLeaderDefinition, getTreacheryCardDefinition } from '../../data';
import {
  type PhaseHandler,
  type PhaseStepResult,
  type AgentRequest,
  type AgentResponse,
  type PhaseEvent,
  type BattlePhaseContext,
  type PendingBattle,
  type CurrentBattle,
} from '../types';

// =============================================================================
// BATTLE PHASE HANDLER
// =============================================================================

export class BattlePhaseHandler implements PhaseHandler {
  readonly phase = Phase.BATTLE;

  private context: BattlePhaseContext = {
    pendingBattles: [],
    currentBattleIndex: 0,
    currentBattle: null,
    subPhase: BattleSubPhase.AGGRESSOR_CHOOSING,
    aggressorOrder: [],
    currentAggressorIndex: 0,
  };

  initialize(state: GameState): PhaseStepResult {
    // Reset context
    this.context = {
      pendingBattles: [],
      currentBattleIndex: 0,
      currentBattle: null,
      subPhase: BattleSubPhase.AGGRESSOR_CHOOSING,
      aggressorOrder: [...state.stormOrder],
      currentAggressorIndex: 0,
    };

    const events: PhaseEvent[] = [];
    // Note: PhaseManager emits PHASE_STARTED event, so we don't emit it here

    // Identify all territories with multiple factions
    this.context.pendingBattles = this.identifyBattles(state);

    if (this.context.pendingBattles.length === 0) {
      events.push({
        type: 'NO_BATTLES',
        data: { phase: Phase.BATTLE },
        message: 'No battles this turn',
      });

      return {
        state,
        phaseComplete: true,
        nextPhase: Phase.SPICE_COLLECTION,
        pendingRequests: [],
        actions: [],
        events,
      };
    }

    events.push({
      type: 'BATTLE_STARTED',
      data: { totalBattles: this.context.pendingBattles.length },
      message: `${this.context.pendingBattles.length} potential battles identified`,
    });

    // Start first battle selection
    return this.requestBattleChoice(state, events);
  }

  processStep(state: GameState, responses: AgentResponse[]): PhaseStepResult {
    const events: PhaseEvent[] = [];
    const newState = state;

    switch (this.context.subPhase) {
      case BattleSubPhase.AGGRESSOR_CHOOSING:
        return this.processChooseBattle(newState, responses, events);

      case BattleSubPhase.PRESCIENCE_OPPORTUNITY:
        return this.processPrescience(newState, responses, events);

      case BattleSubPhase.PRESCIENCE_REVEAL:
        return this.processPrescienceReveal(newState, responses, events);

      case BattleSubPhase.CREATING_BATTLE_PLANS:
        return this.processBattlePlans(newState, responses, events);

      case BattleSubPhase.VOICE_OPPORTUNITY:
        return this.processVoice(newState, responses, events);

      case BattleSubPhase.REVEALING_PLANS:
        return this.processReveal(newState, events);

      case BattleSubPhase.TRAITOR_CALL:
        return this.processTraitor(newState, responses, events);

      case BattleSubPhase.BATTLE_RESOLUTION:
        return this.processResolution(newState, events);

      default:
        return {
          state: newState,
          phaseComplete: true,
          nextPhase: Phase.SPICE_COLLECTION,
          pendingRequests: [],
          actions: [],
          events,
        };
    }
  }

  cleanup(state: GameState): GameState {
    // Reset all leaders' used state
    let newState = state;
    for (const faction of state.factions.keys()) {
      newState = resetLeaderTurnState(newState, faction);
    }
    // Reset Kwisatz Haderach turn state for Atreides
    if (state.factions.has(Faction.ATREIDES)) {
      newState = resetKwisatzHaderachTurnState(newState);
    }
    return newState;
  }

  // ===========================================================================
  // BATTLE IDENTIFICATION
  // ===========================================================================

  private identifyBattles(state: GameState): PendingBattle[] {
    const battles: PendingBattle[] = [];
    const checkedLocations = new Set<string>();

    for (const [faction, factionState] of state.factions) {
      for (const forceStack of factionState.forces.onBoard) {
        // NEUTRAL ZONE: Players cannot battle in the Polar Sink
        if (forceStack.territoryId === TerritoryId.POLAR_SINK) continue;

        const locationKey = `${forceStack.territoryId}-${forceStack.sector}`;
        if (checkedLocations.has(locationKey)) continue;
        checkedLocations.add(locationKey);

        const factionsHere = getFactionsInTerritory(
          state,
          forceStack.territoryId
        );

        if (factionsHere.length >= 2) {
          battles.push({
            territoryId: forceStack.territoryId,
            sector: forceStack.sector,
            factions: factionsHere,
          });
        }
      }
    }

    return battles;
  }

  // ===========================================================================
  // BATTLE CHOICE
  // ===========================================================================

  private requestBattleChoice(
    state: GameState,
    events: PhaseEvent[]
  ): PhaseStepResult {
    // Find next aggressor in storm order who has pending battles
    while (this.context.currentAggressorIndex < this.context.aggressorOrder.length) {
      const aggressor = this.context.aggressorOrder[this.context.currentAggressorIndex];

      const availableBattles = this.context.pendingBattles.filter((b) =>
        b.factions.includes(aggressor)
      );

      if (availableBattles.length > 0) {
        const pendingRequests: AgentRequest[] = [
          {
            factionId: aggressor,
            requestType: 'CHOOSE_BATTLE',
            prompt: `You are the aggressor. Choose which battle to fight or pass.`,
            context: {
              availableBattles: availableBattles.map((b) => ({
                territory: b.territoryId,
                sector: b.sector,
                enemies: b.factions.filter((f) => f !== aggressor),
              })),
            },
            availableActions: ['CHOOSE_BATTLE', 'PASS'],
          },
        ];

        return {
          state,
          phaseComplete: false,
          pendingRequests,
          actions: [],
          events,
        };
      }

      this.context.currentAggressorIndex++;
    }

    // No more battles
    return this.endBattlePhase(state, events);
  }

  private processChooseBattle(
    state: GameState,
    responses: AgentResponse[],
    events: PhaseEvent[]
  ): PhaseStepResult {
    const response = responses[0];
    if (!response) {
      this.context.currentAggressorIndex++;
      return this.requestBattleChoice(state, events);
    }

    if (response.passed) {
      this.context.currentAggressorIndex++;
      return this.requestBattleChoice(state, events);
    }

    // Set up the battle
    const territoryId = response.data.territoryId as TerritoryId;
    const sector = response.data.sector as number;
    const defender = response.data.defender as Faction;
    const aggressor = response.factionId;

    // Find this battle in pending
    const battleIndex = this.context.pendingBattles.findIndex(
      (b) =>
        b.territoryId === territoryId &&
        b.sector === sector &&
        b.factions.includes(aggressor) &&
        b.factions.includes(defender)
    );

    if (battleIndex === -1) {
      // Invalid battle choice
      this.context.currentAggressorIndex++;
      return this.requestBattleChoice(state, events);
    }

    // Set up current battle
    this.context.currentBattle = {
      territoryId,
      sector,
      aggressor,
      defender,
      aggressorPlan: null,
      defenderPlan: null,
      prescienceUsed: false,
      prescienceTarget: null,
      prescienceOpponent: null,
      prescienceResult: null,
      voiceUsed: false,
      voiceCommand: null,
      traitorCalled: false,
      traitorCalledBy: null,
      traitorCallsByBothSides: false,
    };

    events.push({
      type: 'BATTLE_STARTED',
      data: {
        territory: territoryId,
        sector,
        aggressor,
        defender,
      },
      message: `Battle: ${aggressor} attacks ${defender} in ${territoryId}`,
    });

    // Check for Atreides prescience
    if (state.factions.has(Faction.ATREIDES)) {
      const atreidesInBattle =
        aggressor === Faction.ATREIDES || defender === Faction.ATREIDES;
      const atreidesAlly = getAlly(state, Faction.ATREIDES);
      const allyInBattle = atreidesAlly && (aggressor === atreidesAlly || defender === atreidesAlly);

      if (atreidesInBattle || allyInBattle) {
        // Determine opponent to use prescience against
        let prescienceTarget: Faction;
        if (atreidesInBattle) {
          prescienceTarget = aggressor === Faction.ATREIDES ? defender : aggressor;
        } else {
          // Ally's battle - target is ally's opponent
          prescienceTarget = aggressor === atreidesAlly ? defender : aggressor;
        }

        this.context.subPhase = BattleSubPhase.PRESCIENCE_OPPORTUNITY;
        return this.requestPrescience(state, events, prescienceTarget);
      }
    }

    // Skip to battle plans
    this.context.subPhase = BattleSubPhase.CREATING_BATTLE_PLANS;
    return this.requestBattlePlans(state, events);
  }

  // ===========================================================================
  // PRESCIENCE (Atreides)
  // ===========================================================================

  private requestPrescience(
    state: GameState,
    events: PhaseEvent[],
    prescienceTarget: Faction
  ): PhaseStepResult {
    const battle = this.context.currentBattle!;
    const atreidesInBattle =
      battle.aggressor === Faction.ATREIDES || battle.defender === Faction.ATREIDES;
    const atreidesAlly = getAlly(state, Faction.ATREIDES);
    const isAllyBattle = atreidesAlly && (battle.aggressor === atreidesAlly || battle.defender === atreidesAlly);

    let promptMessage = `Use prescience to see one element of ${prescienceTarget}'s battle plan?`;
    if (isAllyBattle && !atreidesInBattle) {
      promptMessage = `Your ally ${atreidesAlly} is in battle against ${prescienceTarget}. Use prescience on your ally's opponent?`;
    }

    const pendingRequests: AgentRequest[] = [
      {
        factionId: Faction.ATREIDES,
        requestType: 'USE_PRESCIENCE',
        prompt: promptMessage,
        context: {
          opponent: prescienceTarget,
          allyBattle: isAllyBattle && !atreidesInBattle,
          ally: atreidesAlly,
          options: ['leader', 'weapon', 'defense', 'number'],
        },
        availableActions: ['USE_PRESCIENCE', 'PASS'],
      },
    ];

    return {
      state,
      phaseComplete: false,
      pendingRequests,
      actions: [],
      events,
    };
  }

  private processPrescience(
    state: GameState,
    responses: AgentResponse[],
    events: PhaseEvent[]
  ): PhaseStepResult {
    const response = responses.find((r) => r.factionId === Faction.ATREIDES);
    const battle = this.context.currentBattle!;

    if (response && !response.passed && response.actionType === 'USE_PRESCIENCE') {
      battle.prescienceUsed = true;
      battle.prescienceTarget = response.data.target as 'leader' | 'weapon' | 'defense' | 'number';

      // Determine who the prescience is used against
      const isAggressor = battle.aggressor === Faction.ATREIDES;
      battle.prescienceOpponent = isAggressor ? battle.defender : battle.aggressor;

      events.push({
        type: 'PRESCIENCE_USED',
        data: { target: response.data.target, opponent: battle.prescienceOpponent },
        message: `Atreides uses prescience to see opponent's ${response.data.target}`,
      });

      // Move to reveal phase to get opponent's pre-committed element
      this.context.subPhase = BattleSubPhase.PRESCIENCE_REVEAL;
      return this.requestPrescienceReveal(state, events);
    }

    // Atreides passed, move directly to battle plans
    this.context.subPhase = BattleSubPhase.CREATING_BATTLE_PLANS;
    return this.requestBattlePlans(state, events);
  }

  // ===========================================================================
  // PRESCIENCE REVEAL
  // ===========================================================================

  private requestPrescienceReveal(
    state: GameState,
    events: PhaseEvent[]
  ): PhaseStepResult {
    const battle = this.context.currentBattle!;
    const opponent = battle.prescienceOpponent!;
    const target = battle.prescienceTarget!;

    const factionState = getFactionState(state, opponent);

    // Build context based on what's being revealed
    const context: Record<string, unknown> = {
      prescienceTarget: target,
      territory: battle.territoryId,
      sector: battle.sector,
    };

    // Provide information about what the opponent can choose from
    if (target === 'leader') {
      const availableLeaders = factionState.leaders
        .filter((l) => l.location === LeaderLocation.LEADER_POOL)
        .map((l) => {
          const def = getLeaderDefinition(l.definitionId);
          return {
            id: l.definitionId,
            name: def?.name,
            strength: def?.strength,
          };
        });
      context.availableLeaders = availableLeaders;
    } else if (target === 'weapon' || target === 'defense') {
      const availableCards = factionState.hand.map((c) => {
        const def = getTreacheryCardDefinition(c.definitionId);
        return {
          id: c.definitionId,
          name: def?.name,
          type: def?.type,
        };
      });
      context.availableCards = availableCards;
    } else if (target === 'number') {
      const forces = factionState.forces.onBoard.find(
        (f) => f.territoryId === battle.territoryId && f.sector === battle.sector
      );
      const totalForces = forces
        ? forces.forces.regular + forces.forces.elite
        : 0;
      context.totalForces = totalForces;
      context.spiceAvailable = factionState.spice;
    }

    const pendingRequests: AgentRequest[] = [
      {
        factionId: opponent,
        requestType: 'REVEAL_PRESCIENCE_ELEMENT',
        prompt: `Atreides prescience: Pre-commit your ${target} for this battle.`,
        context,
        availableActions: ['REVEAL_PRESCIENCE_ELEMENT'],
      },
    ];

    return {
      state,
      phaseComplete: false,
      pendingRequests,
      actions: [],
      events,
    };
  }

  private processPrescienceReveal(
    state: GameState,
    responses: AgentResponse[],
    events: PhaseEvent[]
  ): PhaseStepResult {
    const battle = this.context.currentBattle!;
    const response = responses.find((r) => r.factionId === battle.prescienceOpponent);

    if (response && response.actionType === 'REVEAL_PRESCIENCE_ELEMENT') {
      const target = battle.prescienceTarget!;
      let revealedValue: string | number;

      // Extract the revealed value based on the target type
      if (target === 'leader') {
        revealedValue = response.data.leaderId as string;
      } else if (target === 'weapon') {
        revealedValue = response.data.weaponCardId as string;
      } else if (target === 'defense') {
        revealedValue = response.data.defenseCardId as string;
      } else if (target === 'number') {
        // Number could be forces or spice (we store both)
        revealedValue = {
          forces: response.data.forcesDialed as number,
          spice: response.data.spiceDialed as number,
        } as unknown as string;
      } else {
        revealedValue = 'unknown';
      }

      battle.prescienceResult = {
        type: target,
        value: revealedValue,
      };

      events.push({
        type: 'PRESCIENCE_USED',
        data: {
          target,
          revealed: revealedValue,
          opponent: battle.prescienceOpponent,
        },
        message: `Atreides sees opponent's ${target}: ${JSON.stringify(revealedValue)}`,
      });
    }

    // Move to battle plans
    this.context.subPhase = BattleSubPhase.CREATING_BATTLE_PLANS;
    return this.requestBattlePlans(state, events);
  }

  // ===========================================================================
  // BATTLE PLANS
  // ===========================================================================

  private requestBattlePlans(
    state: GameState,
    events: PhaseEvent[]
  ): PhaseStepResult {
    const battle = this.context.currentBattle!;
    const pendingRequests: AgentRequest[] = [];

    for (const faction of [battle.aggressor, battle.defender]) {
      const factionState = getFactionState(state, faction);
      const isAggressor = faction === battle.aggressor;

      // Get available leaders
      const availableLeaders = factionState.leaders
        .filter((l) => l.location === LeaderLocation.LEADER_POOL)
        .map((l) => {
          const def = getLeaderDefinition(l.definitionId);
          return {
            id: l.definitionId,
            name: def?.name,
            strength: def?.strength,
          };
        });

      // Get available cards
      const availableCards = factionState.hand.map((c) => {
        const def = getTreacheryCardDefinition(c.definitionId);
        return {
          id: c.definitionId,
          name: def?.name,
          type: def?.type,
        };
      });

      // Get forces in battle
      const forces = factionState.forces.onBoard.find(
        (f) => f.territoryId === battle.territoryId && f.sector === battle.sector
      );
      const totalForces = forces
        ? forces.forces.regular + forces.forces.elite
        : 0;

      // Prescience info for Atreides
      let prescienceInfo = null;
      if (
        faction === Faction.ATREIDES &&
        this.context.currentBattle!.prescienceUsed
      ) {
        prescienceInfo = {
          target: this.context.currentBattle!.prescienceTarget,
          opponent: this.context.currentBattle!.prescienceOpponent,
          result: this.context.currentBattle!.prescienceResult,
        };
      }

      pendingRequests.push({
        factionId: faction,
        requestType: 'CREATE_BATTLE_PLAN',
        prompt: `Create your battle plan for the battle in ${battle.territoryId}.`,
        context: {
          isAggressor,
          opponent: isAggressor ? battle.defender : battle.aggressor,
          territory: battle.territoryId,
          sector: battle.sector,
          forcesAvailable: totalForces,
          availableLeaders,
          availableCards,
          spiceAvailable: factionState.spice,
          prescienceInfo,
        },
        availableActions: ['CREATE_BATTLE_PLAN'],
      });
    }

    return {
      state,
      phaseComplete: false,
      pendingRequests,
      simultaneousRequests: true, // Both submit at same time
      actions: [],
      events,
    };
  }

  private processBattlePlans(
    state: GameState,
    responses: AgentResponse[],
    events: PhaseEvent[]
  ): PhaseStepResult {
    const battle = this.context.currentBattle!;

    for (const response of responses) {
      const plan = response.data.plan as BattlePlan;
      if (!plan) continue;

      // Validate plan
      const validation = validateBattlePlan(state, response.factionId, battle.territoryId, plan);
      if (!validation.valid) {
        events.push({
          type: 'BATTLE_PLAN_SUBMITTED',
          data: {
            faction: response.factionId,
            invalid: true,
            errors: validation.errors,
          },
          message: `${response.factionId} battle plan invalid: ${validation.errors[0]?.message}`,
        });
        // Use default plan
        const defaultPlan: BattlePlan = {
          factionId: response.factionId,
          leaderId: null,
          forcesDialed: 0,
          spiceDialed: 0,
          weaponCardId: null,
          defenseCardId: null,
          kwisatzHaderachUsed: false,
          cheapHeroUsed: false,
        };
        if (response.factionId === battle.aggressor) {
          battle.aggressorPlan = defaultPlan;
        } else {
          battle.defenderPlan = defaultPlan;
        }
        continue;
      }

      if (response.factionId === battle.aggressor) {
        battle.aggressorPlan = plan;
      } else {
        battle.defenderPlan = plan;
      }

      events.push({
        type: 'BATTLE_PLAN_SUBMITTED',
        data: { faction: response.factionId },
        message: `${response.factionId} submits battle plan`,
      });
    }

    // Check for BG voice
    if (state.factions.has(Faction.BENE_GESSERIT)) {
      const bgInBattle =
        battle.aggressor === Faction.BENE_GESSERIT ||
        battle.defender === Faction.BENE_GESSERIT;

      const bgAlly = getAlly(state, Faction.BENE_GESSERIT);
      const allyInBattle = bgAlly && (battle.aggressor === bgAlly || battle.defender === bgAlly);

      if (bgInBattle || allyInBattle) {
        // Determine opponent to use Voice against
        let voiceTarget: Faction;
        if (bgInBattle) {
          voiceTarget = battle.aggressor === Faction.BENE_GESSERIT ? battle.defender : battle.aggressor;
        } else {
          // Ally's battle - target is ally's opponent
          voiceTarget = battle.aggressor === bgAlly ? battle.defender : battle.aggressor;
        }

        this.context.subPhase = BattleSubPhase.VOICE_OPPORTUNITY;
        return this.requestVoice(state, events, voiceTarget);
      }
    }

    // Skip to reveal
    this.context.subPhase = BattleSubPhase.REVEALING_PLANS;
    return this.processReveal(state, events);
  }

  // ===========================================================================
  // VOICE (Bene Gesserit)
  // ===========================================================================

  private requestVoice(
    state: GameState,
    events: PhaseEvent[],
    voiceTarget: Faction
  ): PhaseStepResult {
    const battle = this.context.currentBattle!;
    const bgInBattle =
      battle.aggressor === Faction.BENE_GESSERIT ||
      battle.defender === Faction.BENE_GESSERIT;
    const bgAlly = getAlly(state, Faction.BENE_GESSERIT);
    const isAllyBattle = bgAlly && (battle.aggressor === bgAlly || battle.defender === bgAlly);

    let promptMessage = `Use Voice to command ${voiceTarget}?`;
    if (isAllyBattle && !bgInBattle) {
      promptMessage = `Your ally ${bgAlly} is in battle against ${voiceTarget}. Use Voice on your ally's opponent?`;
    }

    const pendingRequests: AgentRequest[] = [
      {
        factionId: Faction.BENE_GESSERIT,
        requestType: 'USE_VOICE',
        prompt: promptMessage,
        context: {
          opponent: voiceTarget,
          allyBattle: isAllyBattle && !bgInBattle,
          ally: bgAlly,
          options: [
            'play_poison_weapon',
            'not_play_poison_weapon',
            'play_projectile_weapon',
            'not_play_projectile_weapon',
            'play_poison_defense',
            'not_play_poison_defense',
            'play_projectile_defense',
            'not_play_projectile_defense',
          ],
        },
        availableActions: ['USE_VOICE', 'PASS'],
      },
    ];

    return {
      state,
      phaseComplete: false,
      pendingRequests,
      actions: [],
      events,
    };
  }

  private processVoice(
    state: GameState,
    responses: AgentResponse[],
    events: PhaseEvent[]
  ): PhaseStepResult {
    const response = responses.find((r) => r.factionId === Faction.BENE_GESSERIT);

    if (response && !response.passed && response.actionType === 'USE_VOICE') {
      const commandStr = response.data.command as string;

      // Parse the command string (e.g., "play_lasgun", "not_play_poison_weapon")
      const voiceCommand = this.parseVoiceCommand(commandStr);

      this.context.currentBattle!.voiceUsed = true;
      this.context.currentBattle!.voiceCommand = voiceCommand;

      const commandDescription = voiceCommand.specificCardName
        ? `${voiceCommand.type === 'play' ? 'play' : 'not play'} ${voiceCommand.specificCardName}`
        : `${voiceCommand.type === 'play' ? 'play' : 'not play'} ${voiceCommand.cardType.replace(/_/g, ' ')}`;

      events.push({
        type: 'VOICE_USED',
        data: { command: voiceCommand },
        message: `Bene Gesserit uses Voice: ${commandDescription}`,
      });
    }

    // Move to reveal
    this.context.subPhase = BattleSubPhase.REVEALING_PLANS;
    return this.processReveal(state, events);
  }

  /**
   * Parse a voice command string into a VoiceCommand object.
   * Examples: "play_lasgun", "not_play_poison_weapon", "play_worthless"
   */
  private parseVoiceCommand(commandStr: string): import('../../types').VoiceCommand {
    const parts = commandStr.split('_');
    const type = parts[0] === 'play' ? 'play' : 'not_play';

    // Remove the 'play' or 'not' prefix
    const remainingParts = type === 'not_play' ? parts.slice(2) : parts.slice(1);

    // Specific card names (single word that's not a category)
    const specificCardNames = ['lasgun', 'shield', 'snooper'];
    const remainingStr = remainingParts.join('_');

    // Check if this is a specific card by name
    if (specificCardNames.includes(remainingStr)) {
      // Determine if it's a weapon or defense
      const isWeapon = remainingStr === 'lasgun';
      return {
        type,
        cardType: isWeapon ? 'specific_weapon' : 'specific_defense',
        specificCardName: remainingStr,
      };
    }

    // Otherwise, it's a card type category
    return {
      type,
      cardType: remainingStr as any,
    };
  }

  // ===========================================================================
  // REVEAL AND RESOLUTION
  // ===========================================================================

  private processReveal(
    state: GameState,
    events: PhaseEvent[]
  ): PhaseStepResult {
    // Plans are revealed simultaneously
    const battle = this.context.currentBattle!;

    events.push({
      type: 'BATTLE_PLAN_SUBMITTED',
      data: {
        aggressor: battle.aggressor,
        aggressorPlan: this.sanitizePlanForLog(battle.aggressorPlan),
        defender: battle.defender,
        defenderPlan: this.sanitizePlanForLog(battle.defenderPlan),
      },
      message: 'Battle plans revealed!',
    });

    // Validate Voice compliance if Voice was used
    if (battle.voiceUsed && battle.voiceCommand) {
      const bgFaction = battle.aggressor === Faction.BENE_GESSERIT ? battle.aggressor : battle.defender;
      const opponentFaction = battle.aggressor === Faction.BENE_GESSERIT ? battle.defender : battle.aggressor;
      const opponentPlan = battle.aggressor === Faction.BENE_GESSERIT ? battle.defenderPlan : battle.aggressorPlan;

      if (opponentPlan) {
        const voiceErrors = validateVoiceCompliance(state, opponentPlan, battle.voiceCommand);

        if (voiceErrors.length > 0) {
          // Opponent violated Voice command
          events.push({
            type: 'VOICE_VIOLATION',
            data: {
              faction: opponentFaction,
              command: battle.voiceCommand,
              errors: voiceErrors,
            },
            message: `${opponentFaction} violated Voice command: ${voiceErrors[0].message}`,
          });

          // Note: In the actual game, Voice violations are handled by house rules.
          // For AI simulation, we log the violation but continue with the battle.
          // A stricter implementation could force the plan to be resubmitted.
        } else {
          events.push({
            type: 'VOICE_COMPLIED',
            data: { faction: opponentFaction },
            message: `${opponentFaction} complies with Voice command`,
          });
        }
      }
    }

    // Check for traitor opportunity
    this.context.subPhase = BattleSubPhase.TRAITOR_CALL;
    return this.requestTraitorCall(state, events);
  }

  private requestTraitorCall(
    state: GameState,
    events: PhaseEvent[]
  ): PhaseStepResult {
    const battle = this.context.currentBattle!;
    const pendingRequests: AgentRequest[] = [];

    // Both sides can potentially call traitor
    for (const faction of [battle.aggressor, battle.defender]) {
      const factionState = getFactionState(state, faction);
      const opponent = faction === battle.aggressor ? battle.defender : battle.aggressor;
      const opponentPlan =
        faction === battle.aggressor ? battle.defenderPlan : battle.aggressorPlan;

      // Check if opponent's leader is in this faction's traitor cards
      const opponentLeader = opponentPlan?.leaderId;
      const hasTraitor =
        opponentLeader &&
        factionState.traitors.some((t) => t.leaderId === opponentLeader);

      if (hasTraitor) {
        // ATREIDES LOYALTY: A leader accompanied by Kwisatz Haderach cannot turn traitor
        // (battle.md line 61: "A leader accompanied by Kwisatz Haderach can not turn traitor.")
        const opponentUsedKH =
          opponent === Faction.ATREIDES &&
          opponentPlan?.kwisatzHaderachUsed === true;

        if (opponentUsedKH) {
          // Kwisatz Haderach protects the leader from being called as traitor
          events.push({
            type: 'TRAITOR_BLOCKED',
            data: {
              faction,
              opponent,
              opponentLeader,
              reason: 'kwisatz_haderach_protection',
            },
            message: `${faction} cannot call traitor on ${opponent}'s leader: protected by Kwisatz Haderach`,
          });
          continue; // Skip this traitor opportunity
        }

        pendingRequests.push({
          factionId: faction,
          requestType: 'CALL_TRAITOR',
          prompt: `${opponent}'s leader ${opponentLeader} is your traitor! Call traitor?`,
          context: {
            opponentLeader,
            opponent,
          },
          availableActions: ['CALL_TRAITOR', 'PASS'],
        });
      }
    }

    if (pendingRequests.length === 0) {
      // No traitor opportunities, resolve battle
      this.context.subPhase = BattleSubPhase.BATTLE_RESOLUTION;
      return this.processResolution(state, events);
    }

    return {
      state,
      phaseComplete: false,
      pendingRequests,
      simultaneousRequests: true,
      actions: [],
      events,
    };
  }

  private processTraitor(
    state: GameState,
    responses: AgentResponse[],
    events: PhaseEvent[]
  ): PhaseStepResult {
    // Count how many sides called traitor
    const traitorCallers: Faction[] = [];

    for (const response of responses) {
      if (!response.passed && response.actionType === 'CALL_TRAITOR') {
        traitorCallers.push(response.factionId);

        events.push({
          type: 'TRAITOR_REVEALED',
          data: {
            caller: response.factionId,
            traitor: response.data.leaderId,
          },
          message: `${response.factionId} calls traitor!`,
        });
      }
    }

    // Check for TWO TRAITORS scenario
    if (traitorCallers.length === 2) {
      // Both sides called traitor - TWO TRAITORS rule applies
      this.context.currentBattle!.traitorCalled = true;
      this.context.currentBattle!.traitorCalledBy = null; // Both called, so null
      this.context.currentBattle!.traitorCallsByBothSides = true;

      events.push({
        type: 'TWO_TRAITORS',
        data: {
          callers: traitorCallers,
        },
        message: 'TWO TRAITORS! Both leaders are traitors for each other.',
      });
    } else if (traitorCallers.length === 1) {
      // Single traitor call - normal traitor resolution
      this.context.currentBattle!.traitorCalled = true;
      this.context.currentBattle!.traitorCalledBy = traitorCallers[0];
    }

    // Resolve battle
    this.context.subPhase = BattleSubPhase.BATTLE_RESOLUTION;
    return this.processResolution(state, events);
  }

  private processResolution(
    state: GameState,
    events: PhaseEvent[]
  ): PhaseStepResult {
    const battle = this.context.currentBattle!;
    let newState = state;

    // Ensure we have valid plans
    const aggressorPlan = battle.aggressorPlan ?? this.createDefaultPlan(battle.aggressor);
    const defenderPlan = battle.defenderPlan ?? this.createDefaultPlan(battle.defender);

    // Check for TWO TRAITORS scenario first
    let result: BattleResult;
    if (battle.traitorCallsByBothSides) {
      // Use the TWO TRAITORS resolution
      result = resolveTwoTraitorsBattle(
        state,
        battle.territoryId,
        battle.aggressor,
        battle.defender,
        aggressorPlan,
        defenderPlan
      );
    } else {
      // Normal battle resolution (including single traitor)
      const traitorTarget = battle.traitorCalled
        ? (battle.traitorCalledBy === battle.aggressor
            ? defenderPlan.leaderId
            : aggressorPlan.leaderId)
        : null;

      result = resolveBattle(
        state,
        battle.territoryId,
        battle.aggressor,
        battle.defender,
        aggressorPlan,
        defenderPlan,
        battle.traitorCalled ? battle.traitorCalledBy : null,
        traitorTarget
      );
    }

    // Apply battle results
    newState = this.applyBattleResult(newState, battle, result, events);

    // Remove this battle from pending
    this.context.pendingBattles = this.context.pendingBattles.filter(
      (b) =>
        !(
          b.territoryId === battle.territoryId &&
          b.sector === battle.sector &&
          b.factions.includes(battle.aggressor) &&
          b.factions.includes(battle.defender)
        )
    );

    // Check for more battles
    this.context.currentBattle = null;
    this.context.subPhase = BattleSubPhase.AGGRESSOR_CHOOSING;

    if (this.context.pendingBattles.length === 0) {
      return this.endBattlePhase(newState, events);
    }

    return this.requestBattleChoice(newState, events);
  }

  private applyBattleResult(
    state: GameState,
    battle: CurrentBattle,
    result: BattleResult,
    events: PhaseEvent[]
  ): GameState {
    let newState = state;

    // Handle lasgun-shield explosion
    if (result.lasgunjShieldExplosion) {
      events.push({
        type: 'LASGUN_SHIELD_EXPLOSION',
        data: { territory: battle.territoryId, sector: battle.sector },
        message: 'Lasgun-Shield explosion! All forces in territory destroyed!',
      });

      // Kill all forces in territory
      for (const faction of [battle.aggressor, battle.defender]) {
        const factionState = getFactionState(newState, faction);
        const forces = factionState.forces.onBoard.find(
          (f) =>
            f.territoryId === battle.territoryId && f.sector === battle.sector
        );
        if (forces) {
          const total = forces.forces.regular + forces.forces.elite;
          newState = sendForcesToTanks(
            newState,
            faction,
            battle.territoryId,
            battle.sector,
            total
          );
        }
      }

      // Kill both leaders
      if (battle.aggressorPlan?.leaderId) {
        newState = killLeader(newState, battle.aggressor, battle.aggressorPlan.leaderId);
      }
      if (battle.defenderPlan?.leaderId) {
        newState = killLeader(newState, battle.defender, battle.defenderPlan.leaderId);
      }

      return newState;
    }

    // Normal battle resolution
    events.push({
      type: 'BATTLE_RESOLVED',
      data: {
        winner: result.winner,
        loser: result.loser,
        winnerTotal: result.winnerTotal,
        loserTotal: result.loserTotal,
        traitorRevealed: result.traitorRevealed,
      },
      message: `${result.winner} wins the battle (${result.winnerTotal} vs ${result.loserTotal})`,
    });

    // Loser loses all forces
    const loser = result.loser;
    const loserForces = getFactionState(newState, loser).forces.onBoard.find(
      (f) => f.territoryId === battle.territoryId && f.sector === battle.sector
    );
    if (loserForces) {
      const total = loserForces.forces.regular + loserForces.forces.elite;
      newState = sendForcesToTanks(
        newState,
        loser,
        battle.territoryId,
        battle.sector,
        total
      );
    }

    // Loser's leader dies (if used)
    const loserPlan =
      loser === battle.aggressor ? battle.aggressorPlan : battle.defenderPlan;
    if (loserPlan?.leaderId) {
      newState = killLeader(newState, loser, loserPlan.leaderId);
      events.push({
        type: 'LEADER_KILLED',
        data: { faction: loser, leaderId: loserPlan.leaderId },
        message: `${loser}'s leader killed in battle`,
      });
    }

    // Winner loses forces equal to the number they dialed on the Battle Wheel
    const winner = result.winner;
    const winnerPlan =
      winner === battle.aggressor ? battle.aggressorPlan : battle.defenderPlan;
    const winnerLosses = winnerPlan?.forcesDialed ?? 0;
    if (winnerLosses > 0) {
      const winnerForces = getFactionState(newState, winner).forces.onBoard.find(
        (f) =>
          f.territoryId === battle.territoryId && f.sector === battle.sector
      );
      if (winnerForces) {
        const actualLosses = Math.min(
          winnerLosses,
          winnerForces.forces.regular + winnerForces.forces.elite
        );
        newState = sendForcesToTanks(
          newState,
          winner,
          battle.territoryId,
          battle.sector,
          actualLosses
        );
      }
    }

    // Mark leaders as used (unless traitor was revealed - winner's leader returns to pool)
    if (winnerPlan?.leaderId) {
      if (result.traitorRevealed) {
        // Winner's leader returns to pool immediately per traitor rules
        newState = returnLeaderToPool(newState, winner, winnerPlan.leaderId);
        events.push({
          type: 'LEADER_RETURNED',
          data: { faction: winner, leaderId: winnerPlan.leaderId },
          message: `${winner}'s leader returns to pool after traitor reveal`,
        });
      } else {
        newState = markLeaderUsed(
          newState,
          winner,
          winnerPlan.leaderId,
          battle.territoryId
        );
      }
    }

    // Mark Kwisatz Haderach as used if applicable
    if (winnerPlan?.kwisatzHaderachUsed && winner === Faction.ATREIDES) {
      newState = markKwisatzHaderachUsed(newState, battle.territoryId);
      events.push({
        type: 'KWISATZ_HADERACH_USED',
        data: { territory: battle.territoryId },
        message: 'Atreides uses Kwisatz Haderach (+2 strength)',
      });
    }

    // Apply spice payouts for killed leaders
    // Winner receives spice equal to the strength of all killed leaders
    for (const payout of result.spicePayouts) {
      newState = addSpice(newState, payout.faction, payout.amount);
      events.push({
        type: 'SPICE_COLLECTED',
        data: {
          faction: payout.faction,
          amount: payout.amount,
          reason: payout.reason,
        },
        message: `${payout.faction} receives ${payout.amount} spice: ${payout.reason}`,
      });
    }

    newState = logAction(newState, 'BATTLE_RESOLVED', null, {
      territory: battle.territoryId,
      sector: battle.sector,
      aggressor: battle.aggressor,
      defender: battle.defender,
      winner: result.winner,
      loser: result.loser,
    });

    return newState;
  }

  private endBattlePhase(
    state: GameState,
    events: PhaseEvent[]
  ): PhaseStepResult {
    // Note: PhaseManager emits PHASE_ENDED event, so we just signal completion
    events.push({
      type: 'BATTLES_COMPLETE',
      data: { phase: Phase.BATTLE },
      message: 'All battles resolved',
    });

    return {
      state,
      phaseComplete: true,
      nextPhase: Phase.SPICE_COLLECTION,
      pendingRequests: [],
      actions: [],
      events,
    };
  }

  private createDefaultPlan(faction: Faction): BattlePlan {
    return {
      factionId: faction,
      leaderId: null,
      forcesDialed: 0,
      spiceDialed: 0,
      weaponCardId: null,
      defenseCardId: null,
      kwisatzHaderachUsed: false,
      cheapHeroUsed: false,
    };
  }

  private sanitizePlanForLog(plan: BattlePlan | null): Record<string, unknown> {
    if (!plan) return { empty: true };
    return {
      leader: plan.leaderId,
      forces: plan.forcesDialed,
      spice: plan.spiceDialed,
      weapon: plan.weaponCardId ? '***' : null,
      defense: plan.defenseCardId ? '***' : null,
    };
  }
}
